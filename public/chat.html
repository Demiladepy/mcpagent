<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Resource Allocation ‚Äì Chat</title>
	<link rel="preconnect" href="https://fonts.googleapis.com" />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
	<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&display=swap" rel="stylesheet" />
	<style>
		:root {
			--bg: #0c0c0f;
			--bg-elevated: #12121a;
			--surface: #18181f;
			--surface-hover: #1e1e28;
			--border: #2a2a36;
			--border-focus: #3d3d4d;
			--text: #f1f1f4;
			--text-secondary: #a1a1aa;
			--text-muted: #71717a;
			--accent: #6366f1;
			--accent-hover: #818cf8;
			--accent-muted: rgba(99, 102, 241, 0.15);
			--success: #22c55e;
			--error: #ef4444;
			--radius: 12px;
			--radius-sm: 8px;
			--shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
		}

		* { box-sizing: border-box; }
		body {
			font-family: 'DM Sans', system-ui, -apple-system, sans-serif;
			background: var(--bg);
			color: var(--text);
			margin: 0;
			min-height: 100vh;
			line-height: 1.5;
		}

		.container {
			max-width: 800px;
			margin: 0 auto;
			padding: 1.5rem;
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
		}

		.header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			flex-wrap: wrap;
			gap: 0.75rem;
		}

		.header h1 {
			font-size: 1.5rem;
			font-weight: 700;
			margin: 0;
			letter-spacing: -0.02em;
		}

		.header a {
			color: var(--text-secondary);
			text-decoration: none;
			font-size: 0.875rem;
		}
		.header a:hover { color: var(--accent); }

		.status-bar {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			font-size: 0.8125rem;
			color: var(--text-muted);
		}

		.status-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			background: var(--text-muted);
			transition: background 0.2s;
		}
		.status-dot.connected { background: var(--success); box-shadow: 0 0 8px var(--success); }
		.status-dot.error { background: var(--error); }
		.status-dot.connecting { animation: pulse 1.2s ease-in-out infinite; }

		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.4; }
		}

		.panel {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: var(--radius);
			padding: 1.25rem;
			box-shadow: var(--shadow);
		}

		.panel h2 {
			font-size: 0.6875rem;
			font-weight: 600;
			margin: 0 0 0.75rem 0;
			color: var(--text-muted);
			text-transform: uppercase;
			letter-spacing: 0.08em;
		}

		.state-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 1rem;
		}
		@media (max-width: 500px) { .state-grid { grid-template-columns: 1fr; } }

		.state-block strong {
			display: block;
			font-size: 0.8125rem;
			color: var(--text-secondary);
			margin-bottom: 0.25rem;
		}

		#stateAssignments, #stateNotifications {
			font-size: 0.875rem;
			margin: 0;
			padding-left: 1.25rem;
			color: var(--text-secondary);
		}
		#stateAssignments li, #stateNotifications li { margin: 0.35rem 0; }

		#log {
			min-height: 260px;
			max-height: 45vh;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			gap: 0.75rem;
			padding: 0.25rem 0;
		}
		#log::-webkit-scrollbar { width: 6px; }
		#log::-webkit-scrollbar-track { background: transparent; }
		#log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

		.msg {
			padding: 0.75rem 1rem;
			border-radius: var(--radius-sm);
			font-size: 0.9375rem;
			max-width: 88%;
			line-height: 1.5;
		}
		.msg.user {
			background: var(--accent);
			color: #fff;
			align-self: flex-end;
			border-bottom-right-radius: 4px;
		}
		.msg.assistant {
			background: var(--bg-elevated);
			border: 1px solid var(--border);
			align-self: flex-start;
			border-bottom-left-radius: 4px;
		}
		.msg .role-label {
			font-size: 0.6875rem;
			text-transform: uppercase;
			letter-spacing: 0.06em;
			margin-bottom: 0.25rem;
			opacity: 0.8;
		}

		.input-row {
			display: flex;
			gap: 0.5rem;
			align-items: stretch;
			flex-wrap: wrap;
			margin-top: 1rem;
		}

		.user-id-wrap {
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}
		.user-id-wrap label {
			font-size: 0.8125rem;
			color: var(--text-muted);
			white-space: nowrap;
		}

		input[type="text"] {
			flex: 1;
			min-width: 160px;
			padding: 0.625rem 1rem;
			border: 1px solid var(--border);
			border-radius: var(--radius-sm);
			background: var(--bg-elevated);
			color: var(--text);
			font-size: 0.9375rem;
			font-family: inherit;
			transition: border-color 0.15s, box-shadow 0.15s;
		}
		input[type="text"]::placeholder { color: var(--text-muted); }
		input[type="text"]:focus {
			outline: none;
			border-color: var(--accent);
			box-shadow: 0 0 0 3px var(--accent-muted);
		}

		#userId { width: 100px; flex: 0 0 100px; }

		button {
			padding: 0.625rem 1.25rem;
			border-radius: var(--radius-sm);
			border: none;
			font-size: 0.9375rem;
			font-weight: 500;
			cursor: pointer;
			font-family: inherit;
			transition: background 0.15s, transform 0.05s;
		}
		button:active { transform: scale(0.98); }
		button.primary {
			background: var(--accent);
			color: #fff;
		}
		button.primary:hover:not(:disabled) { background: var(--accent-hover); }
		button.secondary {
			background: var(--surface-hover);
			color: var(--text);
			border: 1px solid var(--border);
		}
		button.secondary:hover:not(:disabled) {
			background: var(--border);
			border-color: var(--border-focus);
		}
		button:disabled { opacity: 0.5; cursor: not-allowed; }

		.recommendations {
			margin-top: 1rem;
			padding-top: 1rem;
			border-top: 1px solid var(--border);
			font-size: 0.875rem;
			color: var(--text-secondary);
		}
		.recommendations strong { color: var(--text); }
		.recommendations ul { margin: 0.5rem 0 0 1rem; padding: 0; }
		.recommendations li { margin: 0.25rem 0; }
	</style>
</head>
<body>
	<div class="container">
		<header class="header">
			<h1>Resource Allocation</h1>
			<div class="status-bar">
				<span class="status-dot connecting" id="statusDot"></span>
				<span id="status">Connecting‚Ä¶</span>
			</div>
			<a href="/">‚Üê Home</a>
		</header>

		<div class="panel">
			<h2>Live state</h2>
			<div class="state-grid">
				<div class="state-block">
					<strong>My assignments</strong>
					<ul id="stateAssignments">‚Äî</ul>
				</div>
				<div class="state-block">
					<strong>Notifications</strong>
					<ul id="stateNotifications">‚Äî</ul>
				</div>
			</div>
		</div>

		<div class="panel">
			<h2>Chat</h2>
			<div id="log"></div>
			<div class="input-row">
				<div class="user-id-wrap">
					<label for="userId">User</label>
					<input type="text" id="userId" value="user-1" placeholder="user-1" />
				</div>
				<input type="text" id="input" placeholder="Request P1, return P1, list resources, or ask anything‚Ä¶" />
				<button type="button" id="send" class="primary">Send</button>
				<button type="button" id="voice" class="secondary" title="Record voice (transcript sent to chat)">üé§ Voice</button>
			</div>
			<div class="recommendations" id="recommendations"></div>
		</div>
	</div>

	<script type="module">
		const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
		const wsUrl = `${wsProtocol}//${location.host}/agents/resource-allocation-agent/default`;
		const pendingCalls = new Map();
		let ws = null;

		function setStatus(text, state = '') {
			document.getElementById('status').textContent = text;
			const dot = document.getElementById('statusDot');
			dot.className = 'status-dot ' + (state || (text === 'Connected' ? 'connected' : text === 'Error' || text === 'Disconnected' ? 'error' : 'connecting'));
		}

		function connect() {
			ws = new WebSocket(wsUrl);
			ws.onopen = () => setStatus('Connected', 'connected');
			ws.onclose = () => setStatus('Disconnected', 'error');
			ws.onerror = () => setStatus('Error', 'error');
			ws.onmessage = (event) => {
				try {
					const msg = JSON.parse(event.data);
					if (msg.type === 'cf_agent_state' && msg.state) updateStateUI(msg.state);
					if (msg.type === 'rpc' && msg.id && pendingCalls.has(msg.id)) {
						const { resolve, reject } = pendingCalls.get(msg.id);
						pendingCalls.delete(msg.id);
						if (msg.success) resolve(msg.result); else reject(new Error(msg.error));
					}
				} catch (_) {}
			};
		}

		function call(method, args = []) {
			return new Promise((resolve, reject) => {
				if (!ws || ws.readyState !== WebSocket.OPEN) {
					reject(new Error('Not connected'));
					return;
				}
				const id = crypto.randomUUID();
				pendingCalls.set(id, { resolve, reject });
				ws.send(JSON.stringify({ type: 'rpc', id, method, args }));
			});
		}

		function updateStateUI(state) {
			const userId = document.getElementById('userId').value.trim() || 'user-1';
			const assignments = (state.assignments || []).filter(a => a.userId === userId && a.status === 'active');
			const notifications = (state.notifications || {})[userId] || [];
			document.getElementById('stateAssignments').innerHTML = assignments.length
				? assignments.map(a => `<li>${a.resourceId} (due ${(a.dueReturnAt || '‚Äî').slice(0, 10)})</li>`).join('')
				: '<li>None</li>';
			document.getElementById('stateNotifications').innerHTML = notifications.length
				? notifications.map(n => `<li>${escapeHtml(n)}</li>`).join('')
				: '<li>None</li>';
		}

		function escapeHtml(s) {
			const div = document.createElement('div');
			div.textContent = s;
			return div.innerHTML;
		}

		function appendMessage(role, content) {
			const log = document.getElementById('log');
			const div = document.createElement('div');
			div.className = `msg ${role}`;
			div.textContent = content;
			log.appendChild(div);
			log.scrollTop = log.scrollHeight;
		}

		async function loadRecommendations() {
			const userId = document.getElementById('userId').value.trim() || 'user-1';
			try {
				const list = await call('getRecommendations', [userId]);
				const el = document.getElementById('recommendations');
				if (Array.isArray(list) && list.length) {
					el.innerHTML = '<strong>Suggestions</strong><ul>' + list.map(s => '<li>' + escapeHtml(s) + '</li>').join('') + '</ul>';
				} else {
					el.innerHTML = '';
				}
			} catch (_) {
				document.getElementById('recommendations').innerHTML = '';
			}
		}

		async function sendMessage() {
			const input = document.getElementById('input');
			const userId = document.getElementById('userId').value.trim() || 'user-1';
			const text = input.value.trim();
			if (!text) return;
			input.value = '';
			appendMessage('user', text);
			document.getElementById('send').disabled = true;
			try {
				const reply = await call('handleChat', [userId, text]);
				appendMessage('assistant', reply);
				loadRecommendations();
			} catch (e) {
				appendMessage('assistant', 'Error: ' + e.message);
			}
			document.getElementById('send').disabled = false;
		}

		let mediaRecorder = null;
		let chunks = [];
		document.getElementById('voice').addEventListener('click', async () => {
			if (mediaRecorder && mediaRecorder.state === 'recording') {
				mediaRecorder.stop();
				return;
			}
			try {
				const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
				mediaRecorder = new MediaRecorder(stream);
				chunks = [];
				mediaRecorder.ondataavailable = (e) => e.data.size && chunks.push(e.data);
				mediaRecorder.onstop = async () => {
					stream.getTracks().forEach(t => t.stop());
					document.getElementById('voice').textContent = 'üé§ Voice';
					const blob = new Blob(chunks, { type: 'audio/webm' });
					const form = new FormData();
					form.append('audio', blob);
					try {
						const r = await fetch('/api/voice', { method: 'POST', body: form });
						const data = await r.json();
						const text = (data && data.text) ? data.text.trim() : '';
						if (text) {
							document.getElementById('input').value = text;
							await sendMessage();
						} else {
							appendMessage('assistant', 'No speech detected or transcription failed.');
						}
					} catch (e) {
						appendMessage('assistant', 'Voice transcription failed: ' + e.message);
					}
				};
				mediaRecorder.start();
				document.getElementById('voice').textContent = '‚èπ Stop';
			} catch (e) {
				appendMessage('assistant', 'Microphone access denied or error: ' + e.message);
			}
		});

		document.getElementById('send').addEventListener('click', sendMessage);
		document.getElementById('input').addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });

		connect();
	</script>
</body>
</html>
